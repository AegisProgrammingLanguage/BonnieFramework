import "stdlib/socket.aeg"
import "lib/http.aeg"
import "lib/middlewares/middleware.aeg"
import "lib/router.aeg"
import "packages/sqlite/sqlite.aeg"

interface RequestHandler {
    handle(req)
}

class Application {
    public host: string = "127.0.0.1"
    public port: int = 8080

    private routes = []
    private middlewares = []

    public get(path, handler) {
        var r = new Route("GET", path, handler)
        this.routes.push(r)
    }

    public post(path, handler) {
        var r = new Route("POST", path, handler)
        this.routes.push(r)
    }

    public use(middleware) {
        this.middlewares.push(middleware)
    }

    public run(host: string, port: int) {
        this.host = host
        this.port = port

        var server_id = Socket.listen(this.host, this.port)
        print "ðŸ”¥ Bonnie is running on http://${this.host}:${this.port}"

        while (true) {
            var client_id = Socket.accept(server_id)

            try {
                var raw_data = Socket.read(client_id, 2048)

                if (raw_data.len() > 0) {
                    var req = new Request(raw_data)
                    print "[REQUEST] ${req.method} ${req.path}"

                    var handled = false

                    foreach (mw in this.middlewares) {
                        var res = mw.handle(req)
                        if (res != null) {
                            this.send_response(client_id, res)
                            handled = true
                            break
                        }
                    }

                    if (!handled) {
                        // 2. ROUTING DYNAMIQUE
                        var found_route = null
                        
                        foreach (route in this.routes) {
                            // On tente le match
                            var params = route.match(req.method, req.path)
                            
                            if (params != null) {
                                req.params = params
                                found_route = route
                                break
                            }
                        }

                        if (found_route != null) {
                            var handler = found_route.handler
                            var response = handler.handle(req)
                            this.send_response(client_id, response)
                        } 
                        else {
                            var not_found = new Response("<h1>404 - Not Found</h1>", 404)
                            this.send_response(client_id, not_found)
                        }
                    }
                }
            } catch (e) {
                print "[SERVER ERROR] " + e
            }

            Socket.close(client_id)
        }
    }

    private send_response(client_id, res) {
        var body_to_send = res.body

        // 1. NORMALISATION : Tout doit devenir des Bytes pour avoir la vraie taille
        if (typeof(body_to_send) == "string") {
            // "ðŸŒ¸".len() = 1, mais "ðŸŒ¸".to_bytes().len() = 4 !
            body_to_send = body_to_send.to_bytes()
        }

        // 2. Mise Ã  jour du Content-Length avec la taille en OCTETS
        // On Ã©crase ce qui a pu Ãªtre calculÃ© avant (qui Ã©tait peut-Ãªtre faux pour les Strings)
        res.set_header("Content-Length", to_str(body_to_send.len()))

        // 3. Envoi sÃ©curisÃ©
        // get_headers_string() va utiliser les headers
        Socket.write(client_id, res.get_headers_string()) 
        
        // On envoie le buffer d'octets (Texte converti ou Image brute)
        Socket.write(client_id, body_to_send)
    }
}
